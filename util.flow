import string_utils;
import text/blueprint;
import exp;
import texp;

export {

// String representation of type
type2s(t: Type) -> string;

// Make the string representation of a (typed) expression (operation inverse to parsing)
exp2s(e: Exp) -> string;
texp2s(e: TExp) -> string;

// Gather all variables from TExp
texpVars(acc: Set<string>, e: TExp) -> Set<string>;

}

type2s(t: Type) -> string {
	switch (t) {
		TypeBool():   "bool";
		TypeInt():    "int";
		TypeString(): "string";
		TypeErr():    "<error type>";
	}
}

exp2s(e: Exp) -> string {
	switch (e) {
		Assign(var, x): {
			var +  " = " + exp2s(x);
		}
		Seq(es): {
			if (length(es) == 1) exp2s(es[0]) else "{\n" + 
				strIndent(superglue(es, exp2s, "\n")) + 
			"\n}";
		}
		Call(op, args): {
			if (length(args) == 0) op else
			if (length(args) == 1) {
				op + exp2s(args[0]);
			} else {
				"(" + superglue(args, exp2s, " " + op + " ") + ")";
			}
		}
		While(cond, e1): {
			"while " + exp2s(cond) + "\n" + strIndent(exp2s(e1));
		}
		If(cond, pos, neg): {
			if (neg == Seq([])) {
				"if " + exp2s(cond) + "\n" + strIndent(exp2s(pos));
			} else {
				"if " + exp2s(cond) + "\n" + strIndent(exp2s(pos)) + "\nelse\n" + strIndent(exp2s(neg));
			}
		}
		Array(vals): {
			"[" + superglue(vals, exp2s, ", ") + "]";
		}
		Print(e1): {
			"print " + exp2s(e1);
		}
		Read(v): {
			"read " + v;
		}
		Var(v): v;
		Int(i): i2s(i)
		Bool(b): b2s(b);
		String(s): "\"" + s + "\"";
	}
}

texp2s(e: TExp) -> string {
	switch (e) {
		TAssign(var, x): {
			var +  " = " + texp2s(x);
		}
		TSeq(es): {
			if (length(es) == 1) texp2s(es[0]) else "{\n" + 
				strIndent(superglue(es, texp2s, "\n")) + 
			"\n}";
		}
		TCall(op, args,__): {
			if (length(args) == 0) op else
			if (length(args) == 1) {
				op + texp2s(args[0]);
			} else {
				"(" + superglue(args, texp2s, " " + op + " ") + ")";
			}
		}
		TWhile(cond, e1): {
			"while " + texp2s(cond) + "\n" + strIndent(texp2s(e1));
		}
		TIf(cond, pos, neg): {
			if (neg == TSeq([])) {
				"if " + texp2s(cond) + "\n" + strIndent(texp2s(pos));
			} else {
				"if " + texp2s(cond) + "\n" + strIndent(texp2s(pos)) + "\nelse\n" + strIndent(texp2s(neg));
			}
		}
		TArray(vals): {
			"[" + superglue(vals, texp2s, ", ") + "]";
		}
		TPrint(e1): {
			"print " + texp2s(e1);
		}
		TRead(v, t): {
			"read " + v;
		}
		TVar(v,__): v;
		TInt(i): i2s(i)
		TBool(b): b2s(b);
		TString(s): "\"" + s + "\"";
	}
}

texpVars(acc: Set<string>, e: TExp) -> Set<string> {
	switch (e) {
		TAssign(v,__):     insertSet(acc, v);
		TSeq(stats):       fold(stats, acc, texpVars);
		TWhile(__,body):   texpVars(acc, body);
		TIf(__, pos, neg): texpVars(texpVars(acc, pos), neg);
		default: acc;
	}
}
