import net/url_parameter;
import fs/filesystem;
import parser;
import typecheck;
import exp2bc;
import exec;

main() {
	file_param = getUrlParameter("file");
	file = changeFileExt(file_param, ".sl");
	if (file_param == "") {
		println(help + "\nno file to run. Please pass file name with file=<name> option.")
	} else if (!fileExists(file)) {
		println("file: " + file_param + " don't exist.");
	} else {
		code = getFileContent(file);
		err = makeErr();
		maybeApply(parse(code, err), \prog -> {
			// The source code was successfully parsed
			if (isUrlParameterTrue("show-parsed") || isUrlParameterTrue("show-all")) {
				println("program:\n" + exp2s(prog));
			}
			maybeApply(typecheck(prog, err), \typed -> {
				// The parsed AST was successfully typed
				if (isUrlParameterTrue("show-typed") || isUrlParameterTrue("show-all")) {
					println("typed:\n" + texp2s(typed));
				}
				maybeApply(prog2bc(typed, err), \bytecode -> {
					// The typed program was successfully compiled to bytecode 
					if (isUrlParameterTrue("show-bytecode") || isUrlParameterTrue("show-all")) {
						println(bcode2s(bytecode));
					}
					if (!isUrlParameterFalse("run")) {
						// Going to run program ...
						in_param = getUrlParameter("in");
						io = if (in_param == "") {
							Io(\ -> readUntil("\n"), println);
						} else {
							// When tests are run automatically, we need to mock the used input.
							// So, the 'user input' is passed via 'in=<s_1>,<s_2>,...,<s_n>' option
							in_seq = strSplit(in_param, ",");
							in_counter = ref 0;
							Io(
								\ -> if (^in_counter >= length(in_seq)) "" else {
									s = in_seq[^in_counter];
									in_counter := ^in_counter + 1;
									s;
								},
								println
							)
						}
						execBcCode(bytecode, isUrlParameterTrue("trace"), err, io);
					}
				});
			});
		});
	}
	quit(0);
}

help = <<
Simple language compiler/runner. Usage:
	java -jar simlang.jar <options> file=<name>

Options:
	show-parsed=1          outputs the result of parsing phase
	show-typed=1           outputs the result of typechecking phase 
	show-bytecode=1        outputs the generated bytecode
	show-all=1             all of the previous together

	run=0                  do not run generated bytecode 
	trace=1                trace the exceution of bytecode
>>