import err;
import texp;
import bc;
import util;

export {
	// Translate the program to the bytecode. In case of errors None is returned.
	prog2bc(p: TExp, err: Err) -> Maybe<BcCode>;
}

prog2bc(prog: TExp, err: Err) -> Maybe<BcCode> {
	vars = set2array(texpVars(makeSet(), prog));
	var2ind = foldi(vars, makeTree(), \i, ac, v -> setTree(ac, v, i));
	var_ind = \v -> switch (lookupTree(var2ind, v)) {
		Some(i): i;
		None(): {
			err.report("var `" + v + "` was not declared");
			-1;
		}
	}
	bytecode = doProg2bc(prog, var_ind, err);
	if (isOk(err)) {
		Some(BcCode(length(vars), bytecode));
	} else {
		None();
	}
}

doProg2bc(s: TExp, var_ind: (string) -> int, err: Err) -> [BcComm] {
	switch (s) {
		TLet(v, __, e): {
			arrayPush(
				doExp2bc(e, var_ind, err),
				BcPop(var_ind(v))
			);
		}
		TAssign(v, e): {
			arrayPush(
				doExp2bc(e, var_ind, err),
				BcPop(var_ind(v))
			);
		}
		TIf(c, pos, neg): {
			if (neg == TSeq([])) {
				pos_code = doProg2bc(pos, var_ind, err);
				concat(
					arrayPush(
						doExp2bc(c, var_ind, err),
						BcIf(length(pos_code) + 1)
					),
					concat(
						pos_code,
						doProg2bc(neg, var_ind, err)
					)
				);
			} else {
				pos_code = doProg2bc(pos, var_ind, err);
				neg_code = doProg2bc(neg, var_ind, err);
				concat(
					arrayPush(
						doExp2bc(c, var_ind, err),
						BcIf(length(pos_code) + 2)
					),
					concat(
						arrayPush(pos_code, BcGoto(length(neg_code) + 1)),
						neg_code
					)
				);
			}
		}
		TWhile(c, s1): {
			cond_code = doExp2bc(c, var_ind, err);
			s1_code = doProg2bc(s1, var_ind, err);
			concat(
				arrayPush(
					cond_code,
					BcIf(length(s1_code) + 2)
				),
				arrayPush(
					s1_code,
					BcGoto(-(length(s1_code) + length(cond_code) + 1))
				)
			);
		}
		TSeq(es): {
			fold(es, [], \acc, x -> concat(acc, doProg2bc(x, var_ind, err)));
		}
		TPrint(e): {
			arrayPush(doExp2bc(e, var_ind, err), BcPrint());
		}
		TRead(v, t): {
			switch (t) {
				TypeBool():   [BcReadBool(var_ind(v))];
				TypeInt():    [BcReadInt(var_ind(v))];
				TypeString(): [BcReadString(var_ind(v))];
				default: {
					err.report("read type is bool, int or string, met:\n" + type2s(t));
					[];
				}
			}
		}
		default: {
			err.report("a statement is expected, met:\n" + texp2s(s));
			[];
		}
	}
}


// This function makes a conversion of a tree-like AST nodes of an expression
// to the RPN-like (Reverse Polish Notation) sequence of commands, which operate
// on the stack of the execution engine.
doExp2bc(e: TExp, var_ind: (string) -> int, err: Err) -> [BcComm] {
	switch (e) {
		TCall(op, args,__): {
			arrayPush(
				// Note! here arguments are reversed (i.e. foldr function is used).
				// Otherwise the order of oerations will be reversed during the execution.
				foldr(args, [], \acc, arg -> concat(acc, doExp2bc(arg, var_ind, err))),
				BcOp(op, length(args))
			);
		}
		TVar(v,__): [BcPush(var_ind(v))];
		TInt(i):    [BcConstInt(i)];
		TBool(b):   [BcConstBool(b)];
		TString(s): [BcConstString(s)];
		default: {
			err.report("statement is met in expression:\n" + texp2s(e) + "\n" + toString(e)); [];
		}
	}
}

