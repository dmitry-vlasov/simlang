import ds/array;
import runtime;
import text/blueprint;
import string_utils;
import sys/system;
import err;
import bc;
import util;

export {

execBcCode(prog: BcCode, trace: bool, err: Err) -> void;

bcode2s(prog: BcCode) -> string;

}

Val ::= ValBool, ValInt, ValString, ValErr;
	ValBool(b: bool);
	ValInt(i: int);
	ValString(s: string);
	ValErr();

State(
	vars: [Val],
	pc: int,
	stack: List<Val>
);

verifyBcCode(prog: BcCode, err: Err) -> bool {
	check_i = \i, c -> if (i < 0 || i >= prog.locals) err.report("illegal var index in: " + comm2s(c));
	iter(prog.code, \c -> switch (c) {
		BcPush(i):       check_i(i, c);
		BcPop(i):        check_i(i, c);
		BcReadBool(i):   check_i(i, c);
		BcReadInt(i):    check_i(i, c);
		BcReadString(i): check_i(i, c);
		default: {}
	});
	isOk(err);
}

execBcCode(prog: BcCode, trace: bool, err: Err) -> void {
	if (verifyBcCode(prog, err)) {
		initial = State(
			generate(0, prog.locals, \__ -> ValInt(0)), 
			0, makeList()
		);
		if (trace) {
			println("initial state: " + state2s(initial));
		}
		ignore(for(initial,
			\s -> isOk(err) && s.pc < length(prog.code),
			\prev -> {
				next = execComm(prog.code[prev.pc], prev, err);
				if (trace) {
					println(comm2s(prog.code[prev.pc]) + ":\n\t" + state2s(next));
				}
				next;
			}
		));
	}
}

execComm(comm:  BcComm, s: State, err: Err) -> State {
	incPc = \x -> State(x with pc = x.pc + 1);
	push = \x, v -> State(x with stack = Cons(v, x.stack));
	pop = \x -> switch (x.stack) {
		Cons(h, t): Pair(h, State(x with stack = t));
		EmptyList(): { err.report("popping empty list"); Pair(ValErr(), x); }
	}
	switch (comm) {
		BcPush(i): {
			incPc(push(s, s.vars[i]));
		}
		BcPop(i): {
			p = pop(s);
			incPc(State(p.second with vars = replace(s.vars, i, p.first)));
		}
		BcPrint(): {
			p = pop(s);
			println(val2s(p.first));
			incPc(p.second);
		}
		BcReadBool(i): {
			incPc(State(s with vars = replace(s.vars, i, ValBool(s2b(readUntil("\n"))))));
		}
		BcReadInt(i): {
			incPc(State(s with vars = replace(s.vars, i, ValInt(s2i(readUntil("\n"))))));
		}
		BcReadString(i): {
			incPc(State(s with vars = replace(s.vars, i, ValString(readUntil("\n")))));
		}
		BcIf(sh): {
			p = pop(s);
			switch (p.first) {
				ValBool(c): {
					State(p.second with pc = s.pc + if (c) 1 else sh);
				}
				default: {
					err.report("non-boolean condition: " + val2s(p.first));
					s;
				}
			}
		}
		BcGoto(sh): {
			State(s with pc = s.pc + sh);
		}
		BcConstBool(b): {
			incPc(push(s, ValBool(b)));
		}
		BcConstInt(i): {
			incPc(push(s, ValInt(i)));
		}
		BcConstString(s1): {
			incPc(push(s, ValString(s1)));
		}
		BcOp(op, arity): {
			// pop arguments from stack and collect them on the second component of triple
			t = for(Triple(s, [], 0),
				\x -> x.third < arity,
				\x -> {
					p = pop(x.first);
					Triple(p.second, arrayPush(x.second, p.first), x.third + 1);
				}
			);
			incPc(push(t.first, execOp(op, t.second, err)));
		}
	}
}

val2int(v: Val, err: Err) -> int {
	switch (v) {
		ValInt(i): i;
		default: {
			err.report("integer expected, while: " + val2s(v) + " is met"); 0;
		}
	}
}

val2bool(v: Val, err: Err) -> bool {
	switch (v) {
		ValBool(b): b;
		default: {
			err.report("boolean expected, while: " + val2s(v) + " is met"); false;
		}
	}
}

val2string(v: Val, err: Err) -> string {
	switch (v) {
		ValString(s): s;
		default: {
			err.report("string expected, while: " + val2s(v) + " is met"); "";
		}
	}
}

execOp(op: string, args: [Val], err: Err) -> Val {
	check_arity = \arity -> if (length(args) != arity) {
		err.report("wrong arity of " + op + ", expected: " + i2s(arity) + " wile got: " + i2s(length(args)));
	}
	int_bin_op = \int_op -> {
		check_arity(2);
		ValInt(int_op(val2int(args[0], err), val2int(args[1], err)));
	}
	cmp_bin_op = \bool_op, int_op, str_op -> {
		check_arity(2);
		switch (valType(args[0])) {
			TypeBool():   ValBool(bool_op(val2bool(args[0], err), val2bool(args[1], err)));
			TypeInt():    ValBool(int_op(val2int(args[0], err), val2int(args[1], err)));
			TypeString(): ValBool(str_op(val2string(args[0], err), val2string(args[1], err)));
			default:      ValErr();
		}
	}
	if (op == "i2s") {
		check_arity(1);
		ValString(i2s(val2int(args[0], err)));
	} else if (op == "s2i") {
		check_arity(1);
		ValInt(s2i(val2string(args[0], err)));
	} else if (op == "b2s") {
		check_arity(1);
		ValString(b2s(val2bool(args[0], err)));
	} else if (op == "s2b") {
		check_arity(1);
		ValBool(s2b(val2string(args[0], err)));
	} else if (op == "i2b") {
		check_arity(1);
		ValBool(val2int(args[0], err) != 0);
	} else if (op == "b2i") {
		check_arity(1);
		ValInt(if (val2bool(args[0], err)) 1 else 0);
	} else if (op == "neg") {
		check_arity(1);
		ValInt(-val2int(args[0], err));
	} else if (op == "not") {
		check_arity(1);
		ValBool(!val2bool(args[0], err));
	} else if (op == "+") {
		switch (valType(args[0])) {
			TypeInt():    ValInt(fold(args, 0, \acc, v -> acc + val2int(v, err)));
			TypeString(): ValString(fold(args, "", \acc, v -> acc + val2string(v, err)));
			default: {
				err.report("+ operands must be of integer or string type, got: " + val2s(args[0])); ValInt(0);
			}
		}
	} else
	if (op == "-")  int_bin_op(\x, y -> x - y) else
	if (op == "*")  int_bin_op(\x, y -> x * y) else
	if (op == "/")  int_bin_op(\x, y -> x / y) else
	if (op == "%")  int_bin_op(\x, y -> x % y) else
	if (op == "==") cmp_bin_op(\x, y -> x == y, \x, y -> x == y, \x, y -> x == y) else
	if (op == "!=") cmp_bin_op(\x, y -> x != y, \x, y -> x != y, \x, y -> x != y) else
	if (op == "<")  cmp_bin_op(\x, y -> x <  y, \x, y -> x <  y, \x, y -> x <  y) else
	if (op == "<=") cmp_bin_op(\x, y -> x <= y, \x, y -> x <= y, \x, y -> x <= y) else
	if (op == ">")  cmp_bin_op(\x, y -> x >  y, \x, y -> x >  y, \x, y -> x >  y) else
	if (op == ">=") cmp_bin_op(\x, y -> x >= y, \x, y -> x >= y, \x, y -> x >= y) else
	if (op == "&&") ValBool(fold(args, true, \acc, v -> acc && val2bool(v, err))) else 
	if (op == "||") ValBool(fold(args, false, \acc, v -> acc || val2bool(v, err))) else {
		err.report("unsupported operation: " + op); ValInt(0);
	}
}

bcode2s(prog: BcCode) -> string {
	"locals: " + i2s(prog.locals) + "\n" + 
	"bytecode: [\n" +
		supergluei(prog.code, \i, c -> "\t" + i2s(i) + ": " + comm2s(c), "\n") + 
	"\n]";
}

comm2s(comm: BcComm) -> string {
	switch (comm) {
		BcPush(i):        "push " + i2s(i);
		BcPop(i):         "pop " + i2s(i);
		BcPrint():        "print";
		BcReadBool(i):    "read bool " + i2s(i);
		BcReadInt(i):     "read int " + i2s(i);
		BcReadString(i):  "read string " + i2s(i);
		BcIf(sh):         "if, else goto +" + i2s(sh);
		BcGoto(sh):       "goto " + i2s(sh);
		BcConstBool(b):   "cbool " + b2s(b);
		BcConstInt(i):    "cint " + i2s(i);
		BcConstString(s): "cstring \"" + s + "\"";
		BcOp(op, a):      "op " + op + ": " + i2s(a);
	}
}

state2s(s: State) -> string {
	"pc = " + i2s(s.pc) + " " + 
	"vars = [" + superglue(s.vars, val2s, ", ") + "] "
	"stack = {" + superglue(list2array(s.stack), val2s, ", ") + "}";
}

val2s(v: Val) -> string {
	switch (v) {
		ValBool(b):   b2s(b);
		ValInt(i):    i2s(i);
		ValString(s): s; 
		ValErr():     "BROKEN VALUE";
	}
}

valType(v: Val) -> Type {
	switch (v) {
		ValBool(__):   TypeBool();
		ValInt(__):    TypeInt();
		ValString(__): TypeString();
		ValErr():      TypeInt();
	}
}
